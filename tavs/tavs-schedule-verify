#!/usr/bin/perl -w

# tave-schedule-verify.pl
# -----------------------
# 
# Part of the TAVS suite.
#
# Script to query OverWatch and, if necessary, run a verify.
#
# Original author: James Thorne <james.thorne@stfc.ac.uk>
# Update for LSI RAID cards and Python conversion: George Christian
#
# (c) Science and Technology Facilities Council

import sys
import getopt
import os
import time
import psycopg2
import socket

### CONSTANTS ###

BINDIR = "/usr/local/sbin";
START_SCRIPT = BINDIR + "/tavs-start-verifies";

### PROGRAM ###

def main():
  ### LOCAL VARIABLES ###
  today = time.strftime("%d%m%Y")

  # User defined variables
  hostname = ""
  username = ""
  password = ""
  dbname = ""
  machineName = ""
  force = False
  logName = "/var/log/tavs.log"
  diskFraction = 5
  DEBUG = False
  noSleep = False
  verifyLimit = 0

  # Read the configuration file
  filepath = ""
  if os.path.isfile("pg_service.conf"):
    filepath = "pg_service.conf"
  elif os.path.isfile("/usr/local/etc/pg_service.conf"):
    filepath = "/usr/local/etc/pg_service.conf"
  else:
    gracefulDeath("Unable to find configuration file pg_service.conf", logfile, 1)

  config = open(filepath, "r")
  for line in config:
    if line[0] == '#' or line[0] == '[': continue
    entry = line.split('=', 1)
    # Strip is used to remove all spaces and carriage return characters
    if entry[0].strip() == "host": hostname = entry[1].strip(' \n')
    elif entry[0].strip() == "user": username = entry[1].strip(' \n')
    elif entry[0].strip() == "password": password = entry[1].strip(' \n')
    elif entry[0].strip() == "port": port = entry[1].strip(' \n')
    elif entry[0].strip() == "dbname": dbname = entry[1].strip(' \n')
    elif entry[0].strip() == "diskfrac": diskFraction = int(entry[1].strip(' \n'))
    elif entry[0].strip() == "log": logName = entry[1].strip(' \n')

  config.close()

  # Open log file
  logfile = open(logName, "a+")

  # get command line options
  #   -d             : debug
  #   -f             : force verify and update DB.  Useful after intervention.
  #   -S             : Do not sleep before contacting DB.
  #   -n             : The machine to run verifies on
  #   -h, -?         : display usage and exit
  lastOpt = ""
  for opt in sys.argv[1:]:
    if opt in ("-h", "-?"):
      usage()
      sys.exit(1)
    elif opt == "-d":
      DEBUG = True
      dbg("Debugging is turned on", DEBUG);
    elif opt == "-S":
      noSleep = True
    elif opt == "-f":
      force = True
    elif opt == "-n":
      lastOpt = opt
      continue
    elif lastOpt == "-n":
      machineName = opt
    else:
      gracefulDeath("Invalid option passed at the command line", logfile, 1)
      usage()

    lastOpt = opt

  if machineName == "":
    machineName = socket.gethostname().split(".", 1)[0]

  dbg("Today's date is %s" % time.strftime("%d/%m/%Y"), DEBUG)
  dbg("My hostname is %s" % machineName, DEBUG)

  if noSleep == False:
    # If we're running normally, we need to sleep for a while to avoid overloading
    # the DB, unless the -S option was specified (no sleep).
    dbg("Sleeping for 5 seconds to avoid loading the DB...", DEBUG)
    time.sleep(5)

  # Connect to the database
  dbg("Connecting to the database", DEBUG)
  connection = psycopg2.connect("dbname=%s user=%s password=%s host=%s" % (dbname, username, password, hostname))
  cur = connection.cursor()

  # If force has been specified then run a check now and exit
  if force == True:
    cur.execute('SELECT "machineName", "storageSystemId" FROM "vCastor5" WHERE "machineName" = %s', (machineName,))
    storageSystemId = cur.fetchone()[1]
    verify(cur, machineName, storageSystemId, "Verify forced", logfile, DEBUG)
    exit(0)

  print("Disk Fraction: %i" % diskFraction)
  cur.execute('SELECT ( COUNT ("diskPool") / %s ) AS "verifyLimit" FROM "vCastor5" WHERE "diskPool" = (SELECT "diskPool" FROM "vCastor5" WHERE "machineName" = %s);', (diskFraction, machineName))
  verifyLimit = cur.fetchone()[0]

  dbg("verifyLimit:\t %i" % verifyLimit, DEBUG)

  # get result and set the limit on the number of concurrent verifies
  # verifyLimit must be at least 1
  if verifyLimit == 0:
    dbg("verifyLimit is zero, shifting to 1", DEBUG)
    verifyLimit += 1

  cur.execute('SELECT "machineName", "diskPool", "lastVerified", "storageSystemId" FROM "vCastor5" WHERE "diskPool" = (SELECT "diskPool" FROM "vCastor5" WHERE "machineName" = %s AND "currentStatus" <> \'Intervention\' AND "currentStatus" <> \'Decomissioned\' AND %s - "lastVerified" > 28 ORDER BY "lastVerified" ASC LIMIT %s);', (machineName, time.strftime("%Y%m%d"), verifyLimit))

  for record in cur:
    oldHost = record[0]
    if oldHost == machineName:
      verify(cur, machineName, record[3], "Host has not been verified in over 28 days", logfile, DEBUG)

  # Close log file
  logfile.close()

### SUBROUTINES ###

def verify(cur, machineName, storageSystemId, reason, logfile, DEBUG):
  dbg(reason, DEBUG)
  dbg("Time to verify", DEBUG)
  dbg("Starting verifies:\t%s" % START_SCRIPT, DEBUG)
  # send info on decision to the log file
  writeToLog("%s" % reason, logfile)
  # execute the verify command
  retVal = os.system(START_SCRIPT)

  # If the verify was successful then update the 'storageSystems' table with the current date
  if retVal == 0:
    dbg("Started verifies on %s" % machineName, DEBUG)
    writeToLog("Started verifies on %s" % machineName, logfile)

    cur.execute('UPDATE "storageSystems" SET "lastVerified" = %s WHERE "id" = %s', (time.strftime("%Y-%m-%d"), storageSystemId))
  else:
    gracefulDeath("Error starting verifies on %s" % machineName, logfile, 1)

def usage():
  print "tavs-schedule-verify usage:\n"
  print "  -d             : turn on debug messages\n"
  print "  -f             : force verify and update DB.  Useful after intervention.\n"
  print "  -n <host name> : short host name (optional, script will guess it otherwise)\n"
  print "  -S             : Do not sleep before contacting DB.  Use when run interactively.\n"
  print "  -h, -?         : display this usage message and exit.\n\n"

def dbg(msg, DEBUG):
  if ( DEBUG ):
    # print to STDERR
    sys.stderr.write(msg + "\n")

def gracefulDeath(errorMsg, logfile, exitCode):
  # print to STDERR
  sys.stderr.write("----\n")
  sys.stderr.write("%s\n" % errorMsg)
  sys.stderr.write("----\n")
  writeToLog('ERROR: ' + errorMsg, logfile);
  sys.exit(1)

def writeToLog(msg, logfile):
  logfile.write("[%s]: %s\n" % (time.strftime("%d/%m/%Y"), msg))

if __name__ == "__main__":
  main()
